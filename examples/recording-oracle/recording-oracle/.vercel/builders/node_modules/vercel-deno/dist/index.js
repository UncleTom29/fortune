"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareCache = exports.build = exports.version = void 0;
/**
 * The default version of Deno that will be downloaded at build-time.
 */
const DEFAULT_DENO_VERSION = 'v1.25.1';
const url_1 = require("url");
const child_process_1 = require("child_process");
const path_1 = require("path");
const fs_extra_1 = require("fs-extra");
const once_1 = __importDefault(require("@tootallnate/once"));
const build_utils_1 = require("@vercel/build-utils");
const shebang = __importStar(require("./shebang"));
const util_1 = require("./util");
const config_1 = require("./config");
const download_deno_1 = require("./download-deno");
const shell_args_1 = require("shell-args");
__exportStar(require("./start-dev-server"), exports);
const bootstrapPath = (0, path_1.join)(__dirname, 'bootstrap');
// `chmod()` is required for usage with `vercel-dev-runtime` since
// file mode is not preserved in Vercel deployments from the CLI.
(0, fs_extra_1.chmodSync)(bootstrapPath, 0o755);
const bootstrapData = (0, fs_extra_1.readFileSync)(bootstrapPath, 'utf8');
const bootstrapMode = (0, fs_extra_1.statSync)(bootstrapPath).mode;
exports.version = 3;
const build = async ({ workPath, files, entrypoint, meta = {}, config = {}, }) => {
    await (0, build_utils_1.download)(files, workPath, meta);
    const absEntrypoint = (0, path_1.join)(workPath, entrypoint);
    const absEntrypointDir = (0, path_1.dirname)(absEntrypoint);
    const args = shebang.parse(await (0, fs_extra_1.readFile)(absEntrypoint, 'utf8'));
    // @deprecated
    const unstable = (0, config_1.configBool)(config, 'denoUnstable', process.env, 'DENO_UNSTABLE') ||
        false;
    // @deprecated
    const denoTsConfig = (0, config_1.configString)(config, 'tsconfig', process.env, 'DENO_TSCONFIG');
    let denoVersion = args['--version'];
    delete args['--version'];
    // @deprecated
    if (!denoVersion) {
        denoVersion = (0, config_1.configString)(config, 'denoVersion', process.env, 'DENO_VERSION');
        if (denoVersion) {
            console.log('DENO_VERSION env var is deprecated');
        }
    }
    if (!denoVersion) {
        denoVersion = DEFAULT_DENO_VERSION;
    }
    if (!denoVersion.startsWith('v')) {
        denoVersion = `v${denoVersion}`;
    }
    const { devCacheDir = (0, path_1.join)(workPath, '.vercel', 'cache') } = meta;
    const denoDir = (0, path_1.join)(devCacheDir, 'deno');
    const env = {
        ...process.env,
        ...args.env,
        DENO_DIR: denoDir,
        ENTRYPOINT: (0, path_1.join)(workPath, entrypoint),
    };
    const [runtimeDeno, buildTimeDeno] = await Promise.all([
        // For runtime, Linux 64-bit Deno binary will be downloaded
        (0, download_deno_1.downloadDeno)(denoDir, denoVersion, 'linux', 'x64'),
        // If the build is being executed on a different OS/arch,
        // then also download Deno binary for the build host
        process.platform !== 'linux' || process.arch !== 'x64'
            ? (0, download_deno_1.downloadDeno)(denoDir, denoVersion, process.platform, process.arch)
            : undefined,
    ]);
    // Add build-time Deno version to $PATH
    const origPath = env.PATH;
    env.PATH = [(buildTimeDeno === null || buildTimeDeno === void 0 ? void 0 : buildTimeDeno.dir) || runtimeDeno.dir, origPath].join(':');
    // @deprecated
    if (unstable) {
        console.log('DENO_UNSTABLE env var is deprecated');
        args['--unstable'] = true;
    }
    // Flags that accept file paths are relative to the entrypoint in
    // the source file, but `deno run` is executed at the root directory
    // of the project, so the arguments need to be relativized to the root
    for (const flag of [
        '--cert',
        '--config',
        '--import-map',
        '--lock',
    ]) {
        const val = args[flag];
        if (typeof val === 'string' && !(0, util_1.isURL)(val)) {
            args[flag] = (0, path_1.relative)(workPath, (0, path_1.resolve)(absEntrypointDir, val));
        }
    }
    // @deprecated
    if (denoTsConfig && !args['--config']) {
        console.log('DENO_TSCONFIG env var is deprecated');
        args['--config'] = denoTsConfig;
    }
    // This flag is specific to `vercel-deno`, so it does not
    // get included in the args that are passed to `deno run`
    const includeFiles = (args['--include-files'] || []).map((f) => {
        return (0, path_1.relative)(workPath, (0, path_1.join)(absEntrypointDir, f));
    });
    delete args['--include-files'];
    const argv = ['--allow-all', ...args];
    console.log(`Caching importsâ€¦`);
    console.log(`deno run ${argv.join(' ')} ${entrypoint}`);
    const cp = (0, child_process_1.spawn)('deno', ['run', ...argv, (0, path_1.join)(__dirname, 'runtime.ts')], {
        env,
        cwd: workPath,
        stdio: 'inherit',
    });
    const [code] = await (0, once_1.default)(cp, 'exit');
    if (code !== 0) {
        throw new Error(`Build script failed with exit code ${code}`);
    }
    const bootstrapDataWithArgs = bootstrapData.replace('$args', (0, shell_args_1.bashShellQuote)(argv));
    const outputFiles = {
        bootstrap: new build_utils_1.FileBlob({
            data: bootstrapDataWithArgs,
            mode: bootstrapMode,
        }),
        'bin/deno': await build_utils_1.FileFsRef.fromFsPath({
            fsPath: (0, path_1.join)(runtimeDeno.dir, 'deno'),
        }),
    };
    await Promise.all([
        traceDenoInfo(outputFiles, env, denoDir, workPath, (0, path_1.join)(__dirname, 'runtime.ts'), '.vercel-deno-runtime.ts'),
        traceDenoInfo(outputFiles, env, denoDir, workPath, (0, path_1.join)(workPath, entrypoint)),
    ]);
    // Add additional files that were referenced from
    // Deno CLI flags in the shebang
    const additionalFiles = new Set();
    for (const flag of [
        '--cert',
        '--config',
        '--import-map',
        '--lock',
    ]) {
        const val = args[flag];
        if (typeof val === 'string' && !(0, util_1.isURL)(val)) {
            additionalFiles.add(val);
        }
    }
    for (const filename of Array.from(additionalFiles).sort()) {
        outputFiles[filename] = await build_utils_1.FileFsRef.fromFsPath({
            fsPath: (0, path_1.join)(workPath, filename),
        });
    }
    // Add additional files that were referenced from
    // `--include-files` CLI flag or the `vercel.json` config
    if (config.includeFiles) {
        if (typeof config.includeFiles === 'string') {
            includeFiles.push(config.includeFiles);
        }
        else {
            includeFiles.push(...config.includeFiles);
        }
    }
    if (includeFiles.length > 0) {
        for (const pattern of includeFiles) {
            const matches = await (0, build_utils_1.glob)(pattern, workPath);
            for (const name of Object.keys(matches)) {
                if (!outputFiles[name]) {
                    outputFiles[name] = matches[name];
                }
            }
        }
    }
    const output = new build_utils_1.Lambda({
        files: outputFiles,
        handler: entrypoint,
        runtime: 'provided.al2',
        environment: args.env,
        supportsWrapper: true,
    });
    return { output };
};
exports.build = build;
async function traceDenoInfo(files, env, denoDir, cwd, entrypoint, renameFile = '', renameDir = '/var/task') {
    const cp = (0, child_process_1.spawn)('deno', ['info', '--json', entrypoint], {
        env,
        cwd,
        stdio: ['ignore', 'pipe', 'inherit'],
    });
    const [stdout, [code]] = await Promise.all([
        (0, build_utils_1.streamToBuffer)(cp.stdout),
        (0, once_1.default)(cp, 'exit'),
    ]);
    if (code !== 0) {
        throw new Error(`Build script failed with exit code ${code}`);
    }
    const info = JSON.parse(stdout.toString('utf8'));
    const root = info.roots[0];
    const outputDenoDir = (0, path_1.relative)(cwd, denoDir);
    const renamedDenoDir = (0, path_1.join)(outputDenoDir, 'gen/file', renameDir);
    for (const mod of info.modules) {
        if (mod.specifier.startsWith('file://')) {
            const outputPath = (root === mod.specifier && renameFile) ||
                (0, path_1.relative)(cwd, mod.local);
            // Add source file to output files
            files[outputPath] = await build_utils_1.FileFsRef.fromFsPath({
                fsPath: mod.local,
            });
            // Add gen `.meta` file to output files
            const metaPath = (0, path_1.join)(denoDir, 'gen/file', `${mod.local}.meta`);
            const metaOutputPath = (0, path_1.join)(renamedDenoDir, `${outputPath}.meta`);
            await build_utils_1.FileFsRef.fromFsPath({
                fsPath: metaPath,
            }).then((ref) => {
                files[metaOutputPath] = ref;
            }, (err) => {
                // Won't exist for "JavaScript" mediaType so "ENOENT" is ok
                if (err.code !== 'ENOENT')
                    throw err;
            });
            // Add gen compiled source file to output files
            const compiledPath = (0, path_1.join)(denoDir, 'gen/file', `${mod.local}.js`);
            const compiledOutputPath = (0, path_1.join)(renamedDenoDir, `${outputPath}.js`);
            await build_utils_1.FileFsRef.fromFsPath({
                fsPath: compiledPath,
            }).then((ref) => {
                files[compiledOutputPath] = ref;
            }, (err) => {
                // Won't exist for "JavaScript" mediaType so "ENOENT" is ok
                if (err.code !== 'ENOENT')
                    throw err;
            });
            // Patch `.buildinfo` file with updated Deno dir file references
            // NOTE: As of `deno` v1.23.0, `.buildinfo` files are no
            // longer created, so this logic can be removed eventually
            const buildInfoPath = (0, path_1.join)(denoDir, 'gen/file', `${mod.local}.buildinfo`);
            const buildInfoOutputPath = (0, path_1.join)(renamedDenoDir, `${outputPath}.buildinfo`);
            await (0, fs_extra_1.readJSON)(buildInfoPath).then((buildInfo) => {
                const fileNames = buildInfo.program.fileNames;
                if (!fileNames) {
                    console.log(`No buildinfo files detected for: "${buildInfoPath}"`);
                    return;
                }
                for (let i = 0; i < fileNames.length; i++) {
                    const fileName = fileNames[i];
                    if (fileName.startsWith('file://')) {
                        const filePath = (0, url_1.fileURLToPath)(fileName);
                        const outputPath = (root === fileName && renameFile) ||
                            (0, path_1.relative)(cwd, filePath);
                        const outputURL = (0, url_1.pathToFileURL)((0, path_1.join)(renameDir, outputPath));
                        fileNames[i] = outputURL.href;
                    }
                }
                files[buildInfoOutputPath] = new build_utils_1.FileBlob({
                    data: JSON.stringify(buildInfo, null, 2),
                });
            }, (err) => {
                if (err.code !== 'ENOENT')
                    throw err;
            });
        }
        else if (mod.specifier.startsWith('https://')) {
            const depPath = (0, path_1.relative)((0, path_1.join)(denoDir, 'deps'), mod.local);
            // Add deps source file to output files
            const depOutputPath = (0, path_1.join)(outputDenoDir, 'deps', depPath);
            files[depOutputPath] = await build_utils_1.FileFsRef.fromFsPath({
                fsPath: (0, path_1.join)(denoDir, 'deps', depPath),
            });
            // Add deps `.metadata.json` file to output files
            const metadataPath = `${depPath}.metadata.json`;
            const metadataOutputPath = (0, path_1.join)(outputDenoDir, 'deps', metadataPath);
            files[metadataOutputPath] = await build_utils_1.FileFsRef.fromFsPath({
                fsPath: (0, path_1.join)(denoDir, 'deps', metadataPath),
            });
            try {
                // Add gen `.meta` file to output files
                const metaPath = `${depPath}.meta`;
                const metaOutputPath = (0, path_1.join)(outputDenoDir, 'gen', metaPath);
                files[metaOutputPath] = await build_utils_1.FileFsRef.fromFsPath({
                    fsPath: (0, path_1.join)(denoDir, 'gen', metaPath),
                });
                // Add gen compiled source file to output files
                const compiledPath = `${depPath}.js`;
                const compiledOutputPath = (0, path_1.join)(outputDenoDir, 'gen', compiledPath);
                files[compiledOutputPath] = await build_utils_1.FileFsRef.fromFsPath({
                    fsPath: (0, path_1.join)(denoDir, 'gen', compiledPath),
                });
            }
            catch (err) {
                // "ENOENT" is ok because `.d.ts` files will not have compiled files
                if (err.code !== 'ENOENT')
                    throw err;
            }
        }
        else {
            throw new Error(`Unsupported file protocol: ${mod.specifier}`);
        }
    }
}
const prepareCache = async ({ workPath }) => {
    return await (0, build_utils_1.glob)('.vercel/cache/deno/**', workPath);
};
exports.prepareCache = prepareCache;
//# sourceMappingURL=index.js.map